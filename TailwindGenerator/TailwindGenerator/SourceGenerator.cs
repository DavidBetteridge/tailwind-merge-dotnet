using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace TailwindGenerator;

/// <summary>
/// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
/// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
/// </summary>
[Generator]
public class SourceGenerator : IIncrementalGenerator
{
    private const string Namespace = "TailwindMerge";
    private const string AttributeName = "GeneratedTailwindClassAttribute";

    private const string AttributeSourceCode = $@"// <auto-generated/>

namespace {Namespace}
{{
    [System.AttributeUsage(System.AttributeTargets.Method)]
    public class {AttributeName}(string ClassList) : System.Attribute;
}}";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add the marker attribute to the compilation.
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "GeneratedTailwindClassAttribute.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetClassDeclarationForSourceGen(ctx));
        IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndEnums
            = context.CompilationProvider.Combine(classDeclarations.Collect());
        context.RegisterSourceOutput(compilationAndEnums,
            (spc, source) => GenerateCode(spc, source.Item1, source.Item2));
        
        // var provider = context.SyntaxProvider
        //     .CreateSyntaxProvider(
        //         (s, _) => IsSyntaxTargetForGeneration(s),
        //         (ctx, _) => GetClassDeclarationForSourceGen(ctx))
        //     .Select((t, _) => t);
        //
        // // Generate the source code.
        // context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
        //     ((ctx, t) => GenerateCode(ctx, t.Left, t.Right)));
    }
    private static bool IsSyntaxTargetForGeneration(SyntaxNode syntaxNode)
    {
        if (syntaxNode is ClassDeclarationSyntax classSyntax)
        {
            var methodAttributes = classSyntax.Members
                .OfType<MethodDeclarationSyntax>()
                .SelectMany(f => f.AttributeLists)
                .ToList();

            return methodAttributes.Any(al =>
                al.Attributes.Any(attribute => attribute.Name.ToString() == "GeneratedTailwindClass"));
        }

        return false;
    }

    private static ClassDeclarationSyntax GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        return classDeclarationSyntax;
    }

    
    
    /// <summary>
    /// Generate code action.
    /// It will be executed on specific nodes (ClassDeclarationSyntax annotated with the [Report] attribute) changed by the user.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="classDeclarations">Nodes annotated with the [Report] attribute that trigger the generate action.</param>
    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        // Go through all filtered class declarations.
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            // We need to get semantic model of the class to retrieve metadata.
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            // Symbols allow us to get the compile-time information.
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            // 'Identifier' means the token of the node. Get class name from the syntax node.
            var className = classDeclarationSyntax.Identifier.Text;

            // Go through all class members with a particular type (property) to generate method lines.
            var methodBody = classDeclarationSyntax.Members
                .OfType<MethodDeclarationSyntax>()
                .Select(p => new {name = p.Identifier.Text, classes = FindClassList(p)})
                .Where(p => !string.IsNullOrWhiteSpace(p.classes))
                .Select(p =>
                    $@"        private static partial TailwindClass {p.name}() => new({p.classes});");

            // private static partial TailwindClass Example1_Lhs() => new("hover:inline bg-grey-5");
            
            // Build up the source code
            var code = $@"// <auto-generated/>

using System;

namespace {namespaceName};

partial class {className}
{{
    
    { string.Join("\n", methodBody) }
}}
";

            // Add the source code to the compilation.
            context.AddSource($"{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    private string? FindClassList(MethodDeclarationSyntax methodDeclarationSyntax)
    {
        var methodAttributeLists = methodDeclarationSyntax.AttributeLists;
        foreach (var methodAttributes in methodAttributeLists)
        {
            foreach (var methodAttribute in methodAttributes.Attributes)
            {
                if (methodAttribute.Name.ToString() == "GeneratedTailwindClass")
                {
                    var classes = methodAttribute.ArgumentList!.Arguments.First().ToString();
                    return classes;
                }
            }
        }

        return null;
    }
}