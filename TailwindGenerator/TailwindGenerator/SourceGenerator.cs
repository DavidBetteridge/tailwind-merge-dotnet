using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using TailwindMerge;

namespace TailwindGenerator;

[Generator]
public class SourceGenerator : IIncrementalGenerator
{
    private const string Namespace = "TailwindMerge";
    private const string AttributeName = "GeneratedTailwindClassAttribute";

    private const string AttributeSourceCode = $@"// <auto-generated/>

namespace {Namespace}
{{
    [System.AttributeUsage(System.AttributeTargets.Method)]
    public class {AttributeName}(string ClassList) : System.Attribute;
}}";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add the marker attribute to the compilation.
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "GeneratedTailwindClassAttribute.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetClassDeclarationForSourceGen(ctx));
        IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndEnums
            = context.CompilationProvider.Combine(classDeclarations.Collect());
        context.RegisterSourceOutput(compilationAndEnums,
            (spc, source) => GenerateCode(spc, source.Item1, source.Item2));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode syntaxNode)
    {
        if (syntaxNode is ClassDeclarationSyntax classSyntax)
        {
            var methodAttributes = classSyntax.Members
                .OfType<MethodDeclarationSyntax>()
                .SelectMany(f => f.AttributeLists)
                .ToList();

            return methodAttributes.Any(al =>
                al.Attributes.Any(attribute => attribute.Name.ToString() == "GeneratedTailwindClass"));
        }

        return false;
    }

    private static ClassDeclarationSyntax GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        return classDeclarationSyntax;
    }

    private static string? Clean(string? val) => val?.Replace(@"""","");
    
    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        var twMerge = new TwMerge();

        // Go through all filtered class declarations.
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            // We need to get semantic model of the class to retrieve metadata.
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            // Symbols allow us to get the compile-time information.
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            // 'Identifier' means the token of the node. Get class name from the syntax node.
            var className = classDeclarationSyntax.Identifier.Text;

            // Go through all class members with a particular type (property) to generate method lines.
            var methodBody = classDeclarationSyntax.Members
                .OfType<MethodDeclarationSyntax>()
                .Select(p => new { name = p.Identifier.Text, classes = FindClassList(p) })
                .Where(p => !string.IsNullOrWhiteSpace(p.classes)).ToList();

            var methodBodies = new List<string>();
            foreach (var method in methodBody)
            {
                var classes = twMerge.SplitClassList(method.classes!).ToList();
                var classesText = classes.Select(c => $@"new ClassInfo(""{Clean(c.Name)}"", ""{Clean(c.GroupId)}"", ""{Clean(c.ModifierId)}"", {c.IsTailwindClass.ToString().ToLowerInvariant()}, {c.HasPostfixModifier.ToString().ToLowerInvariant()})");
                var classesCode = string.Join(",\n", classesText);
                methodBodies.Add(
                    $@"        private static partial TailwindClass {method.name}()
                       {{ 
                            ClassInfo[] classes = [
                                {classesCode}
                            ]; 
                            return new TailwindClass({method.classes}, classes);
                       }}");
            }
            
            // ClassInfo(
            //     string Name,
            //     string? GroupId,
            //     string? ModifierId,
            //     bool IsTailwindClass,
            //     bool HasPostfixModifier )

            // Build up the source code
            var code = $@"// <auto-generated/>

using System;
using TailwindMerge.Models;
namespace {namespaceName};

partial class {className}
{{
    
    {string.Join("\n", methodBodies)}
}}
";

            // Add the source code to the compilation.
            context.AddSource($"{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    private string? FindClassList(MethodDeclarationSyntax methodDeclarationSyntax)
    {
        var methodAttributeLists = methodDeclarationSyntax.AttributeLists;
        foreach (var methodAttributes in methodAttributeLists)
        {
            foreach (var methodAttribute in methodAttributes.Attributes)
            {
                if (methodAttribute.Name.ToString() == "GeneratedTailwindClass")
                {
                    var classes = methodAttribute.ArgumentList!.Arguments.First().ToString();
                    return classes;
                }
            }
        }

        return null;
    }
}